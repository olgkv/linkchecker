# Web links status service

Простой веб-сервис на Go.

## Сборка и запуск

Сборка бинарника:

```bash
go build -o bin/webserver ./cmd/webserver
```

Запуск из исходников:

```bash
go run ./cmd/webserver
```

По умолчанию сервис слушает порт `8080`.

### Переменные окружения

В текущей версии большинство настроек захардкожено, но при необходимости легко выносится в переменные окружения, например:

- `PORT` — порт HTTP-сервера (по умолчанию `8080`).
- `TASKS_FILE` — путь к файлу с задачами (по умолчанию `tasks.json`).

Изменение порта/пути можно добавить в `cmd/webserver/main.go` через чтение `os.Getenv`.

## API

### POST /links

Тело запроса:

```json
{"links": ["google.com", "malformedlink.gg"]}
```

Ответ:

```json
{"links": {"google.com": "available", "malformedlink.gg": "not available"}, "links_num": 1}
```

Каждый запрос получает уникальный номер `links_num`, который хранится на диске в файле `tasks.json`. Это позволяет переживать перезапуски сервиса без потери уже созданных задач и их результатов.

### POST /report

Тело запроса:

```json
{"links_list": [1, 2]}
```

Ответ: PDF-файл с отчетом по всем ссылкам, входящим в переданные задачи.

Примеры curl-запросов:

```bash
# проверка ссылок
curl -X POST http://localhost:8080/links \
  -H "Content-Type: application/json" \
  -d '{"links": ["google.com", "malformedlink.gg"]}'

# генерация отчёта по ранее сохранённым задачам
curl -X POST http://localhost:8080/report \
  -H "Content-Type: application/json" \
  -d '{"links_list": [1, 2]}' \
  --output report.pdf
```

## Проверка доступности ссылок

Для каждой ссылки выполняется HTTP-запрос (если протокол не указан, добавляется `https://`). Статус:

- `available` — код ответа 2xx–3xx
- `not available` — ошибка запроса или иной код ответа

## Устойчивость к перезапускам

- Все задачи (`links_num`, список ссылок, результаты проверки) сериализуются в файл `tasks.json`.
- Запись ведется в файл через временный файл и атомарный `rename`, чтобы избежать порчи данных при падении.
- При старте сервис читает `tasks.json` и восстанавливает все ранее созданные задачи и их номера.

## Архитектура

Проект разделен на слои:

- `cmd/webserver` — точка входа и настройка HTTP-сервера (маршруты, graceful shutdown).
- `internal/domain` — доменные сущности (`Task`, `LinkStatus` и статусы `available`/`not available`).
- `internal/storage` — файловое хранилище задач (`tasks.json`), ответственное за устойчивость к перезапускам.
- `internal/service` — бизнес-логика проверки ссылок и подготовки данных для отчёта.
- `internal/httpapi` — HTTP-хендлеры, маппинг JSON-запросов/ответов на доменную модель.
- `internal/pdf` — генерация PDF-отчёта.

Такое разделение упрощает тестирование (можно отдельно тестировать хранение, HTTP-слой и бизнес-логику) и замену инфраструктуры (например, переход с файлового хранилища на БД) без изменения внешнего API.

Во время перезапуска уже запущенные HTTP-запросы будут корректно завершены (graceful shutdown), новые запросы будут обслужены после старта нового процесса.

## Архитектурные паттерны

- **Graceful shutdown** — при получении SIGINT/SIGTERM сервер прекращает приём новых соединений, дожидается завершения активных запросов и только затем останавливается. Реализовано через `signal.NotifyContext` и `http.Server.Shutdown`.
- **Параллельная обработка** — внутри одного запроса `/links` проверки доменов выполняются в несколько горутин с ограничением по числу одновременных проверок (до 100), что позволяет обрабатывать большие батчи без блокировки приема других запросов.
- **Persisted log (append-only storage)** — каждая проверка (`links_num`) добавляет новую запись в файл `tasks.json`, прошлые записи не изменяются, что обеспечивает неизменяемость истории.
 - **Backoff-retry** — при временных сетевых ошибках проверки ссылок выполняются с небольшими повторными попытками и экспоненциальной задержкой (с уважением к контексту и общему таймауту запроса).

## Логи

Сервис использует стандартный пакет `log` и пишет сообщения в stdout/stderr в текстовом виде, например:

- `server listening on :8080` — успешный запуск сервера.
- `load storage: <err>` — ошибка при чтении `tasks.json` на старте.
- `server shutdown error: <err>` — ошибка при остановке сервера.

Формат логов простой: одно сообщение на строку, без структурирования. При необходимости поверх можно поставить системный логгер (systemd, docker logs, ELK и т.п.) или заменить `log` на structured‑logging библиотеку.
